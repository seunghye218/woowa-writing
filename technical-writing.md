# 웹 브라우저에 URL을 입력하면 어떤 일이 일어날까?

안녕하세요, 우아한 테크 코스 백엔드 6기 마크입니다. 취업 준비 시즌이 다가오며 면접 단골 질문이기도 한 이 주제를 깊게 알아보고싶어 이번에 웹 브라우저에 URL을 입력하면 어떤 일이 일어나는지 다뤄보려고 합니다. 

면접관이 이 질문을 하는 의도가 무엇일지 먼저 알아보려고 합니다. 

이 질문의 의도는 회사의 도메인, 신입 채용인지, 경력자 채용인지에 따라 다양하게 해석될 수 있습니다. 몇 가지 일반적인 의도를 분석해 보겠습니다.

1. 기본적인 네트워킹 이해 확인: 이 질문은 지원자가 네트워킹 기초 지식을 갖추고 있는지 확인하려는 목적이 있습니다. 이를 통해 IP 주소, DNS, HTTP 프로토콜, 그리고 TCP/IP 스택의 동작을 설명할 수 있는지 파악하려고 합니다.

2. 웹 브라우저와 웹 서버의 상호작용 이해: 이 질문은 웹 브라우저가 서버와 통신하는 과정을 얼마나 잘 이해하고 있는지 평가하기 위한 것입니다. 여기에는 HTTP 요청 및 응답, 쿠키 처리, SSL/TLS 암호화 등 웹 기술에 대한 지식을 요구할 수 있습니다.

3. 시스템 전반에 대한 폭넓은 이해: 엔지니어링 전반에서 요구되는 다양한 시스템 레이어들에 대한 이해도를 평가할 수 있습니다. 지원자가 OSI 모델의 각 계층, 운영체제 내부 동작, 캐싱 메커니즘 등 전체 시스템 아키텍처를 얼마나 깊이 이해하고 있는지 확인하는 데 초점을 맞춥니다.

4. 디버깅 능력 및 문제 해결 능력 평가: 이 질문은 문제 해결 능력을 테스트하는 역할도 합니다. 지원자가 각 과정에서 발생할 수 있는 문제들을 진단하고 해결하는 방법을 제시할 수 있는지 확인하려는 의도가 있을 수 있습니다.

5. 회사의 기술 스택에 맞춘 질문: 특정 회사에서는 자신들의 기술 스택에 따라 더 구체적인 답변을 원할 수 있습니다. 예를 들어, 프론트엔드 개발자는 브라우저 렌더링 과정을, 백엔드 개발자는 서버에서의 데이터 처리 과정을 강조할 가능성이 높습니다.

6. 지원자의 CS 지식 깊이 확인: 기본적인 개념에서부터, 보다 복잡한 세부 사항까지 파악하고 싶은 경우에 사용됩니다. 예를 들어, 네트워크 패킷의 흐름, 브라우저 엔진, 또는 HTTP 상태 코드와 같은 세부 사항을 설명할 수 있는지를 보고자 합니다.

위의 의도들이 각 상황에 맞게 분석될 수 있으며, 이를 통해 면접관은 지원자의 기술적 깊이와 폭을 평가할 수 있습니다.

1. 주소창에 URL 을 입력한다.
URL 과 URI 의 차이를 먼저 알고 넘어가자, 공통점과 차이점을 기준으로 설명하자면,

큰 개념으로는 URI 이 있을것 이며, 하위의 작은 개념으로 URL 그리고 URN 이 존재한다.

공통점으로는 모두 Uniform Resource 의 이름을 가지고 있다.

이 말은 즉, 정형화 된 ( 통일된 방식으로 ) 리소스를 표현하는 방법이라고 할 수 있을 것이다.


URI ( Uniform Resource Identifier )
URI 는 ( URL, URN ) 을 포함하는 상위 개념이다.
이름에서 알 수 있듯이 리소스을 식별하는 일반적인 방법을 제공하는 문자열이다.
URL ( Uniform Resource Locator )
Locator 라는 이름과 같이 리소스의 위치를 나타내주고 있다.
하지만 URN 과는 다르게 http: 혹은 https:를 포함하지 않고 있다.
프로토콜, 호스트, 포트 및 리소스 경로와 같은 세부 정보를 포함한다.
리소스가 위치하는 서버와 같은 환경에 따라 변할 수 있기때문에 영구적이다.
URN ( Uniform Resouce Name )
인터넷 상의 리소스의 이름을 식별하는 데 사용된다.
리소스의 이름에 의존하므로, 리소스가 영구적으로 식별된다.
리소스가 이전되거나 서버의 디렉토리 구조가 변경되더라도 URN은 변경되지 않는다.
우리가 질문에서 알 수 있는것은 URL을 입력했을 때 일어나는 일이다.

그 말은 즉, 우리는 주소창에 URL( www.google.com) 만 입력하더라도 페이지 이동이 되는것을 확인 할 수 있다.

또, URL을 입력하는과정에서 우리는 port 번호를 생략해도 입력한것과 같은 행위가 일어나는데,

간단하게 port 에 대해 짚고 넘어가자면, port 라는 이름과 답게 우리는 선적의 목적에 따른 다른 항구를 쓰게 되는것 처럼 각 프로토콜 마다 다른 port 를 찾아가게 되고 대표적으로 몇개만 추리자면,

HTTP 의 프로토콜을 가진 TCP 요청에는 80번
HTTPS 의 프로토콜을 가진 TCP 요청에는 443번
DNS 서버로의 TCP / UDP 요청에는 53번
이 존재한다.

URI 의 개념에서는 프로토콜, 호스트, 포트, 경로, 쿼리 문자열 등이 포함되지만 유저가 이 모든 요소들을 기억하고 입력하는것 자체는 쉽지 않기 때문에, 브라우저 자체에서 URL만 입력하더라도 나머지 정보는 추출 할 수 있는 것 같다.

URL 에 대한 검증과정 ( 브라우저의 URL 파싱 )
이후 URL 이 입력되었고, 유저는 Enter 키를 통해 주소창의 이벤트를 발동 시켰다.

우리는 잘 알고 있듯이, 크롬기준 주소창은 두가지 역할이 가능하다.

주소창에 URL을 입력해 해당 웹 페이지로 이동한다.
구글 검색의 기능을 가지고 있다.
이 과정은 어떻게 이루어지는것일까 ?

보통 개발을 할때 input에 대한 validation 의 과정을 거치듯이 URL에 대한 검증의 과정이 일어날 것이다.

주소창의 input에 입력된 문자열이 URL의 형식을 띄고 있다면, 웹페이지로 이동 하는 로직이 실행되고,

그렇지 않다면 주소창은 검색창의 기능와 같은 역할을 한다.

HSTS 조회 (HTTP Strict Transport Secucrity)
HTTPS 프로토콜로만 접속이 가능하도록 강제화하는 기능.

만약 HTTP 요청일 경우, HTTP 응답 헤더에 String Transport Security 라는 필드를 포함하고 이를 확인한 브라우저는 해당 서버에 요청할때 HTTPS 만을 통해 통신하게 된다.

이후 URL이 HSTS 캐시에 저장되는데 이를 HSTS 목록이라고 한다.

브라우저에서는 이 HSTS 목록 조회를 통해 해당 요청을 HTTPS를 보낼지 판단하게 되며,

HSTS 목록에 해당 URL이 존재한다면 명시적으로 HTTP를 통해 요청한다해도 브라우저가 이를 HTTPS로 요청한다.

2. DNS(Domain Name System) 서버와의 연결
URL 에 대한 검증 과정을 거쳐 통과한 URL 은 파싱의 과정을 가져온 호스트네임 을 기반으로

먼저,

로컬 캐시, 호스트 파일, DNS 서버캐시를 검색한다.

DNS 요청에 대한 응답은 일반적으로 TTL (Time-To-Live) 값을 가지는데, 이는 해당 DNS 정보의 캐시 유효 기간을 나타냅니다. 만약 DNS 정보가 로컬 DNS 캐시에 이미 존재하고, 캐시의 TTL ( Time To Live ) 값이 유효하다면, DNS 클라이언트는 다시 DNS 서버에 요청을 보내지 않고, 로컬 DNS 캐시에서 해당 정보를 가져와서 사용합니다.

용어 :

TTL ( Time to Live )

DNS 레코드의 캐시 유효 시간을 나타내는 값으로, 해당 레코드가 언제까지 유효한지를 나타냅니다. DNS 서버는 이 값에 따라 레코드를 캐시하고, 캐시된 레코드의 유효 기간이 만료되면 해당 레코드를 삭제하게 됩니다. TTL 값은 일반적으로 초 단위로 표시되며, TTL 값이 작을수록 캐시되는 시간이 짧아지므로, DNS 서버에서 다시 조회할 빈도가 높아집니다.

TLD ( Top Level Domain )

DNS 계층 구조에서 최상위 도메인을 나타냅니다. 예를 들어, “.com”, “.org”, “.net” 등이 해당합니다.

캐싱되어 있는 정보가 존재한다면 다음 단계로 넘어갈 것이고, 그렇지 않다면, 아래의 과정을 거치게 됩니다.

Root DNS 서버 찾기:
로컬 DNS 캐시에 요청한 호스트 이름에 대한 정보가 없으면, DNS 클라이언트는 Root DNS 서버의 IP 주소를 찾아야 합니다. 이를 위해, DNS 클라이언트는 미리 설정된 Root DNS 서버의 IP 주소를 사용합니다.
TLD DNS 서버 찾기:
DNS 클라이언트는 Root DNS 서버에서 TLD (Top-Level Domain) DNS 서버의 IP 주소를 얻어와야 합니다. 이를 위해, DNS 클라이언트는 Root DNS 서버에 요청을 보내어, 입력된 호스트 이름의 TLD에 해당하는 DNS 서버의 IP 주소를 얻어옵니다. 예를 들어, 입력된 URL이 "example.com"이라면, DNS 클라이언트는 com TLD DNS 서버의 IP 주소를 얻어와야 합니다.
Authoritative DNS 서버 찾기:
DNS 클라이언트는 TLD DNS 서버에서 입력된 호스트 이름에 대한 Authoritative DNS 서버의 IP 주소를 얻어와야 합니다. 이를 위해, DNS 클라이언트는 TLD DNS 서버에 요청을 보내어, 입력된 호스트 이름에 대한 Authoritative DNS 서버의 IP 주소를 얻어옵니다.
IP 주소 반환:
DNS 클라이언트는 Authoritative DNS 서버로부터 얻어온 호스트 이름에 대한 IP 주소를 사용하여, HTTP 요청을 보내는 서버의 IP 주소를 결정합니다. 이후, HTTP 요청을 해당 서버로 보내어, 페이지를 요청하고, 응답을 받아와서 브라우저에 표시합니다.
이러한 과정을 통해서 브라우저가DNS 서버로 부터 획득한 IP (Internet Protocol) 를 호스팅하는 서버와 연결을 시도하게 됩니다.

IP 주소와 라우터를 이용한 추적
용어 :

Load Balancing : 여러 웹 서버의 부하 분산을 해주는 기능을 합니다.

DNS 서버에서 획득한 IP주소가 라우팅 테이블 내에 존재한다면, 이를 추적하고 존재하지 않는다면 라우팅 알고리즘을 통해 해당 서버의 게이트웨이 까지 이동한다.

각 요청은 가장 성능이 좋은 위치를 통해 지능적으로 라우팅되어 브라우저에 콘텐츠를 전송하고 이 경우, 웹 서버는 원본 서버도 CDN도 아닌 로드 밸런싱(Elastic Load Balancing, ELB) 기능을 이용해 서버를 분산해 부하를 줄여준다.

ARP (Adress Resolution Protocol) 를 통한 MAC 주소 획득
IP 주소를 행정적 주소, MAC 주소를 물리적 주소라고 이해하면 편하다.

IP 주소는 고유하지 않고, 변경이 가능하지만

MAC 주소는 NIC ( Network Interface Card ) 마다 각각의 고유한 주소를 갖는다.

ARP 를 통해 목적지와 실질적으로 통신을 하기위해 ARP Table 내에서 IP 주소를 MAC 주소와 매칭 시킨다.

3. 브라우저와 해당 서버와의 TCP 소켓 연결
먼저, TCP / IP / UDP 라는 말을 많이 들어보게 되는데,

모두 인터넷 프로토콜 스위트(Internet Protocol Suite)에 속하는 프로토콜 protocol 이라는 통신 규약과 관련되있는것을 알 수 있고,

TCP (Transmission Control Protocol)

TCP는 전송 제어 프로토콜이라는 의미를 가지며, 신뢰성이 있는 데이터 전송을 보장합니다.
TCP는 3-way handshake 방식을 이용해 연결 설정과 해제를 수행합니다.
TCP는 데이터의 분할과 재조립, 순서 보장, 오류 제어, 흐름 제어 등의 기능을 제공합니다.
TCP는 HTTP, FTP 등의 애플리케이션에서 사용됩니다.
IP (Internet Protocol)

IP는 인터넷 프로토콜이라는 의미를 가지며, 데이터의 패킷화와 경로 설정을 수행합니다.
IP는 패킷의 출발지와 목적지를 식별하기 위해 IP 주소를 사용합니다. ( endPoint ↔ endPoint )
IP는 패킷을 전송하기 위한 경로를 설정하기 위해 라우팅 테이블을 이용합니다.
IP는 ICMP, IGMP 등의 프로토콜과 함께 인터넷에서 사용됩니다.
UDP (User Datagram Protocol)

UDP는 사용자 데이터그램 프로토콜이라는 의미를 가지며, 신뢰성이 낮은 데이터 전송을 수행합니다.
UDP는 데이터그램을 전송하기 위한 포트 번호와 체크섬 값을 사용합니다.
UDP는 TCP에 비해 전송 속도가 빠르지만, 오류 검출 및 복구 기능이 없기 때문에 신뢰성이 낮습니다.
UDP는 DNS, VoIP, 온라인 게임 등에서 사용됩니다.
간단하게 설명하자면,

IP

네트워크의 데이터의 가장 작은 단위인 패킷의 관계는 이해하지 못하지만 출발지와 목적지를 식별하기 위해 IP 주소를 사용한다.

TCP

데이터를 안정적으로 전송하기 위한 프로토콜로, 3-way handshake 방식을 이용해 연결 설정 및 해제, 데이터 분할과 재조립, 순서 보장, 오류 제어, 흐름 제어 등의 기능을 제공한다.

UDP

데이터 전송의 속도를 높이기 위해 개발된 프로토콜로, 데이터그램을 전송하기 위한 포트 번호와 체크섬 값을 사용합니다. TCP에 비해 전송 속도가 빠르지만, 오류 검출 및 복구 기능이 없기 때문에 신뢰성이 낮다.

그럼, TCP 의 3 way handshake 의 목적과 하는 일은 무었일까 ?

용어 :

SYN, SYN/ACK ,ACK : TCP Header 내의 통신 가능한 정보를 식별하는 패킷이라는 Flag 라 이해.

송신자가 수신자에게 SYN 을 날려 통신이 가능한지 확인 ( 이때 port 가 열려 있어야함 )
수신자가 송신자로부터 SYN 을 받고 SYN/ACK 를 다시 보내주어 통신할 준비가 되었을음 알린다.
송신자가 수신자로부터 SYN/ACK 를 받고, ACK 를 날려 전송을 시작함을 알린다
이 과정에서 데이터의 크기가 큰 경우에는 작은 데이터의 단위로 나누어서 전송하게 된다.

여기서 알 수 있듯이, HTTP 요청와 응답 혹은 통화를 하는것과 같이

통신이 가능하냐 ? → 가능하다 라는 답변 → 그럼 통신을 시작하겠다. 의 과정으로 이루어지는 듯 하다. 이 과정에서

**SYN** , **SYN/ACK** , **ACK** 패킷들을 Flag 로 이용하는것.

4. HTTP / HTTPS 요청과 응답
TCP 연결이 완료 되었다면,

해당 URL에 맞는 서버에 GET 요청을 보내게된다.

웹 브라우저가 서버에 연결되면, HTTP / HTTPS 프로토콜에 대한 통신 규칙을 따르며, 웹 브라우저가 페이지의 콘텐츠를 요청하기 위해 서버에 HTTP 요청을 전송하는 것으로 시작하게 된다.

HTTP 요청에는 요청 라인, 헤더(또는 요청에 대한 메타데이터) 및 본문이 포함되고, 요청에는 클라이언트(이 경우 브라우저)가 수행하려는 작업을 서버가 결정하는 데 사용할 수 있는 정보가 포함되어 있다.

요청에 성공하여 HTTP status 200 OK 라는 응답을 받게 된다면,

이 응답과 같이 서버에서 브라우저에게 index.html 혹은 정적파일 ( 이미지 등… ) 을 전송하게 됩니다.

이후에는 브라우저가 여러개의 콘텐츠를 렌더링 하는 방식중 SSR / CSR 의 개념이 나오게 됩니다.

2. 브라우저가 maps.google.com의 IP 주소를 찾기 위해 캐시에서 DNS 기록을 확인한다.
DNS(Domain Name System)는 인터넷 전화번호부와 같다. DNS는 웹사이트의 IP 주소와 도메인 주소를 연결해주는 시스템이다. 인터넷의 모든 URL에는 고유한 IP 주소가 할당되어 있으며, IP 주소는 액세스 요청 웹 사이트의 서버를 호스트하는 컴퓨터에 속한다. 예를 들어, www.google.com의 IP 주소는 142.250.196.110이다. 따라서 원하는 경우 브라우저에서 https://142.250.196.110 를 입력하여 www.google.com에 접속할 수 있다.

참고: 터미널에서 nslookup google.com 를 치면 해당 ip 주소가 나온다.

DNS의 주요 목적은 사람들이 쉽게 사이트 주소를 찾을 수 있도록 도와주는 것이다. 만약 DNS가 없다면 google.com과 같이 도메인 주소가 아닌, 142.250.196.110 라는 ip 주소를 하나하나 외워서 사이트에 접속할 수 있다. 모든 사이트를 IP 주소로만 접속해야 한다면 정말 어렵지 않을까? 이를 해결하기 위해 DNS를 이용한다. DNS 가 자동으로 URL과 IP 주소를 매핑해주기 때문에, 쉽게 원하는 사이트에 접속할 수 있다.

DNS 기록을 찾기 위해서, 브라우저는 네 개의 캐시를 확인한다.

첫 번째, DNS 쿼리는 우선 브라우저 캐시를 확인한다. 브라우저는 내가 이전에 방문한 웹 사이트의 DNS 기록을 일정 기간 동안 저장하고 있다.

두 번째, 브라우저는 OS 캐시를 확인한다. 브라우저 캐시에 원하는 DNS 레코드가 없다면, 브라우저가 내 컴퓨터 OS에 시스템 호출(ex. 윈도우에서 gethostname 호출)을 통해 DNS 기록을 가져온다. (OS도 DNS 레코드 캐시를 저장하고 있다.)

세 번째, 브라우저는 라우터 캐시를 확인한다. 만약 컴퓨터에도 원하는 DNS 레코드가 없다면, 브라우저는 라우터에서 DNS 기록을 저장한 캐시를 확인한다.

마지막으로, ISP 캐시를 확인한다. 만약 위 모든 단계에서 DNS 기록을 찾지 못한다면, 브라우저는 ISP에서 DNS 기록을 찾는다. ISP(Internet Service Provider)는 DNS 서버를 가지고 있는데, 해당 서버에서 DNS 기록 캐시를 검색할 수 있다.

DNS(Domain Name Server) 서버는 할당된 도메인 영역에 대한 정보를 가지고 있는 서버로, 주로 도메인을 IP주소로 변환하는 역할을 한다.

왜 이렇게 많은 캐시가 유지되고 있을지 의문을 가질 수 있다. 캐싱된 정보가 개인 정보 보호에는 위험할 수 있지만, 캐시는 네트워크 트래픽을 규제하고 데이터 전송 시간을 개선하는 데 필수적이다.

3. 만약 요청한 URL(maps.google.com)이 캐시에 없다면, ISP의 DNS 서버가 DNS 쿼리로 maps.google.com을 호스팅하는 서버의 IP 주소를 찾는다.
앞에서 언급했듯이 내 컴퓨터가 maps.google.com을 호스트하는 서버와 연결하려면 maps.google.com의 IP 주소가 필요하다. DNS 쿼리의 목적은 웹 사이트에 대한 올바른 IP 주소를 찾을 때까지 인터넷에서 여러 DNS 서버를 검색하는 것이다. 필요한 IP 주소를 찾거나, 찾을 수 없다는 오류 응답을 반환할 때까지 한 DNS 서버에서 다른 DNS 서버로 검색이 반복적으로 계속되기 때문에 이 유형의 검색을 재귀적 질의(Recursive Query)라고 한다.

이러한 상황에서, 우리는 ISP의 DNS 서버를 DNS 리커서(DNS Recursor)라고 부르는데, DNS 리커서는 인터넷의 다른 DNS 서버에 답변을 요청하여 의도된 도메인 이름의 적절한 IP 주소를 찾는 일을 담당한다. 다른 DNS 서버는 웹사이트 도메인 이름의 도메인 아키텍처를 기반으로 DNS 검색을 수행하므로 네임 서버(Name Server)라고 한다.

그렇다면 도메인 아키텍처란 어떻게 구성되어 있을까?

domain architechture

사진 출처: Domain Name System: Complicated technology explained in simple terms

오늘날 많은 웹 사이트 URL은 3차 도메인, 2차 도메인 및 최상위 도메인(TLD: Top Level Domain)으로 이뤄진다. 각 단계에는 DNS 룩업(lookup) 도중에 쿼리되는 고유한 네임 서버가 있다.

DNS Lookup 이란 DNS 서버에서 인터넷 도메인 이름을 사용해 인터넷 주소 (ip)를 알아내는 과정이다.

국내 도메인의 경우도 마찬가지이다. 아래와 같이 도메인은 수직적으로 나뉘어져 있다. 예를 들어, kr도메인에는 or영역을 표현하는 or.kr 도메인이 포함되어 있고, or.kr 도메인에는 kisa.or.kr 도메인이 포함되어 있다.
도메인 체계

그림 출처: 그림으로 보는 도메인 체계

그렇다면 다시 maps.google.com 으로 돌아와보자. maps.google.com의 경우 먼저 DNS 리커서가 루트 네임 서버(Root Name Server)에 연결한다. 루트 이름 서버는 리커서를 .com 도메인 네임 서버로 리디렉션한다. .com 네임 서버는 google.com 네임 서버로 리디렉션한다. google.com 네임 서버는 DNS 기록에서 maps.google.com과 일치하는 IP 주소를 찾아 DNS 리커서로 반환하고, 리커서는 이를 브라우저로 다시 보낸다.

위와 같은 요청(Request)은 내용 및 IP 주소(DNS 리커서의 IP 주소)와 같은 정보를 작은 데이터 패킷에 담겨 전송된다. 이 패킷은 올바른 DNS 서버에 도달하기 전에 클라이언트와 서버 사이의 여러 네트워킹 장비를 통해 이동한다. 이 장비는 라우팅 테이블을 사용하여 패킷이 목적지에 도달할 수 있는 가장 빠른 방법을 알아낸다. 만약 이동 도중에 패킷이 손실되면, 요청 실패 오류가 발생한다. 그렇지 않으면 올바른 DNS 서버에 도달하여 IP 주소를 가져온 후 브라우저로 돌아간다.
