# 웹 브라우저에 URL을 입력하면 어떤 일이 일어날까?

취업 준비 시즌이 다가오며 면접 단골 질문이기도 한 이 주제를 깊게 알아보고싶어 이번에 웹 브라우저에 URL을 입력하면 어떤 일이 일어나는지 다뤄보려고 합니다. 
면접관이 이 질문을 하는 의도가 무엇일지 먼저 알아보려고 합니다. 
이 질문의 의도는 회사의 도메인, 채용 직무, 신입, 경력자 채용인지에 따라 다양하게 해석될 수 있습니다. 몇 가지 일반적인 의도를 분석해 보겠습니다.

1. 기본적인 네트워킹 이해 확인: 이 질문은 지원자가 네트워킹 기초 지식을 갖추고 있는지 확인하려는 목적이 있습니다. 이를 통해 IP 주소, DNS, HTTP 프로토콜, 그리고 TCP/IP 스택의 동작을 설명할 수 있는지 파악하려고 합니다.

2. 웹 브라우저와 웹 서버의 상호작용 이해: 이 질문은 웹 브라우저가 서버와 통신하는 과정을 얼마나 잘 이해하고 있는지 평가하기 위한 것입니다. 여기에는 HTTP 요청 및 응답, 쿠키 처리, SSL/TLS 암호화 등 웹 기술에 대한 지식을 요구할 수 있습니다.

3. 시스템 전반에 대한 폭넓은 이해: 엔지니어링 전반에서 요구되는 다양한 시스템 레이어들에 대한 이해도를 평가할 수 있습니다. 지원자가 OSI 모델의 각 계층, 운영체제 내부 동작, 캐싱 메커니즘 등 전체 시스템 아키텍처를 얼마나 깊이 이해하고 있는지 확인하는 데 초점을 맞춥니다.

4. 디버깅 능력 및 문제 해결 능력 평가: 이 질문은 문제 해결 능력을 테스트하는 역할도 합니다. 지원자가 각 과정에서 발생할 수 있는 문제들을 진단하고 해결하는 방법을 제시할 수 있는지 확인하려는 의도가 있을 수 있습니다.

5. 회사의 기술 스택에 맞춘 질문: 특정 회사에서는 자신들의 기술 스택에 따라 더 구체적인 답변을 원할 수 있습니다. 예를 들어, 프론트엔드 개발자는 브라우저 렌더링 과정을, 백엔드 개발자는 서버에서의 데이터 처리 과정을 강조할 가능성이 높습니다.

6. 지원자의 CS 지식 깊이 확인: 기본적인 개념에서부터, 보다 복잡한 세부 사항까지 파악하고 싶은 경우에 사용됩니다. 예를 들어, 네트워크 패킷의 흐름, 브라우저 엔진, 또는 HTTP 상태 코드와 같은 세부 사항을 설명할 수 있는지를 보고자 합니다.

위의 의도들이 각 상황에 맞게 분석될 수 있으며, 이를 통해 면접관은 지원자의 기술적 깊이와 폭을 평가할 수 있습니다.

브라우저 주소창에 URL을 입력하는 순간부터 웹 페이지가 화면에 나타나기까지 다양한 네트워크 프로토콜과 인프라가 복합적으로 작동합니다. 

다음과 같은 단계를 거쳐 웹 페이지가 로딩되며 이를 하나하나 자세히 들여다보겠습니다.

1. URL 입력
2. DNS 조회
3. TCP 연결
4. HTTP 요청
5. 서버 처리 및 응답
6. 브라우저 렌더링

## 1. URL 입력

URL은 무엇일까요?
**URL**(Uniform Resource Locator)은 URI(Uniform Resource Identifier)와 함께 인터넷 상의 자원을 식별하는 데 사용되는 용어입니다. 둘 다 비슷하게 생겼지만, 엄밀히 말하면 다른 의미를 가지고 있습니다.

### URI

URI는 URL 보다 더 넓은 개념으로, 인터넷 상의 모든 자원을 식별하는 데 사용되는 고유한 이름입니다.
자원의 위치뿐만 아니라, 자원에 대한 다양한 정보를 포함할 수 있습니다.

### URL

URI의 한 종류로, 특정 자원의 위치를 나타내는 주소입니다.
웹 페이지, 이미지, 동영상 등 인터넷 상에서 접근 가능한 자원의 위치를 명확하게 지정합니다.

쉽게 이해하기 위해 URI은 도서관에서 책을 찾기 위한 모든 정보 (저자, 제목, 분류번호, 위치 등)이고 URL은 도서관에서 책을 찾기 위한 정확한 위치 정보 (서가, 층수, 책꽂이 번호)로 보면 됩니다.

### URL 분석

브라우저가 URL을 입력받으면 가장 먼저 수행하는 작업이 바로 URL 분석입니다. URL 분석은 단순히 문자열을 나누는 것을 넘어서, 브라우저가 어떤 서버에 어떤 파일을 요청해야 하는지를 정확하게 파악하는 데 필수적인 과정입니다.

- URL의 구성 요소

URL은 크게 다음과 같은 요소들로 구성됩니다.

- 프로토콜: 웹 페이지를 가져오는 데 사용되는 통신 프로토콜 (http, https, ftp 등)을 나타냅니다.
- 도메인: 서버의 이름 또는 IP 주소를 나타냅니다.
- 포트 번호: 서버에서 특정 서비스를 제공하는 포트 번호를 나타냅니다. (생략 가능)
- 경로: 서버의 파일 시스템에서 요청하는 파일의 위치를 나타냅니다.
- 쿼리 문자열: 서버에 추가적인 정보를 전달하기 위한 쌍으로 구성된 데이터입니다.
- 해시: 페이지 내의 특정 위치를 지정하는 데 사용됩니다.

### URL 분석 과정

문자열 분리: 브라우저는 입력된 URL 문자열을 위에서 언급한 구성 요소들로 분리합니다.
유효성 검사: 각 요소의 형식이 올바른지 검사합니다. 예를 들어, 프로토콜은 http, https 등의 유효한 값이어야 합니다.
특수 문자 처리: URL에 포함된 특수 문자들은 URL 인코딩되어 전송되는데, 브라우저는 이를 다시 디코딩하여 원래의 문자로 복원합니다.
상대 경로 처리: 경로가 상대 경로인 경우, 현재 페이지의 URL을 기준으로 절대 경로로 변환합니다.

## 2. DNS 조회

**DNS**(Domain Name System)는 인터넷에서 사용되는 주소 체계입니다. 쉽게 말해, 사람이 기억하기 쉬운 도메인 이름(예: www.example.com)을 컴퓨터가 이해하는 숫자형태의 IP 주소(예: 192.168.0.1)로 바꿔주는 일종의 전화번호부라고 생각하면 됩니다.

### 도메인 이름

먼저 도메인 이름에 대해 알고 넘어가겠습니다.

도메인 이름은 인터넷 상에서 특정 웹사이트나 서버를 나타내는 쉽고 기억하기 쉬운 주소입니다. 마치 우리가 친구의 집을 찾아갈 때, 복잡한 지번 대신 친구의 이름이나 가게 이름을 사용하는 것과 비슷합니다.

- 도메인 이름의 구성 요소

최상위 도메인 (TLD)은 도메인 이름의 가장 오른쪽 부분으로, 웹사이트의 종류나 소속 국가 등을 나타냅니다. 예를 들어, .com, .net, .org, .co.kr 등이 있습니다.
2차 도메인은 최상위 도메인의 왼쪽에 위치하며, 실제 웹사이트의 이름을 나타냅니다. 예를 들어, www.naver.com에서 'naver' 부분이 2차 도메인입니다.
서브 도메인은 2차 도메인의 왼쪽에 추가적으로 붙일 수 있는 부분으로, 웹사이트 내의 특정 서비스나 콘텐츠를 구분하기 위해 사용됩니다. 예를 들어, mail.naver.com에서 'mail' 부분이 서브 도메인입니다.

- 도메인 이름 등록

도메인 등록 기관인 ICANN(인터넷 주소 부여 기관)에서 인증받은 도메인 등록 기관을 통해 도메인 이름을 등록할 수 있습니다.
도메인 유효 기간은 일반적으로 1년 단위로 등록하며, 유효 기간 만료 전에 갱신해야 계속 사용할 수 있습니다.
또한 도메인은 중복 등록이 불가능합니다. 한 번 등록된 도메인 이름은 다른 사람이 사용할 수 없습니다.

### DNS (Domain Name System)

도메인 이름은 사람이 쉽게 기억할 수 있는 주소이지만, 컴퓨터는 IP 주소를 통해 서로 통신합니다. 이 두 가지를 연결해주는 역할을 하는 것이 바로 **DNS**(Domain Name System)입니다.

DNS가 필요한 이유로 크게 세 가지가 있습니다.

첫번째로 사용자 편의성입니다. 복잡한 IP 주소 대신 쉽게 기억할 수 있는 도메인 이름을 사용할 수 있도록 합니다. 컴퓨터는 IP 주소로 서로를 식별하지만, 사람은 숫자로 된 IP 주소를 외우기 어렵습니다. DNS는 이러한 불편함을 해소하고 사용자가 쉽게 웹사이트에 접속할 수 있도록 돕습니다.

두번째는 웹 서비스 접근성입니다. 웹 서버의 위치가 변경되더라도 도메인 이름만 알고 있으면 언제든지 접속할 수 있습니다.
웹 서버의 위치가 변경되더라도 도메인 이름만 알고 있으면 언제든지 접속할 수 있다는 것은 무엇을 의미할까요? 우리가 기억하는 웹사이트 주소(예: www.example.com)는 실제로는 변동될 수 있는 IP 주소를 가리키는 일종의 별칭입니다. DNS 시스템은 이러한 도메인 이름과 IP 주소를 연결하는 일종의 전화번호부 역할을 합니다. 웹 서버의 위치가 변경되면 DNS 서버에 등록된 IP 주소 정보만 바꿔주면 되기 때문에, 사용자는 도메인 이름을 통해 언제나 동일한 웹사이트에 접속할 수 있습니다.
예를 들어, 어떤 회사의 웹 서버가 다른 데이터 센터로 이전된다고 가정해 봅시다. 이 경우, 회사는 DNS 서버에 등록된 IP 주소만 변경하면 되고, 사용자는 기존에 사용하던 도메인 이름으로 계속해서 웹사이트에 접속할 수 있습니다.

세번째는 웹 서비스 분산입니다. 여러 서버에 동일한 웹 서비스를 분산 배치하여 부하를 분산하고 서비스 안정성을 높일 수 있습니다. DNS 설정을 변경함으로써 실시간으로 트래픽 분산 비율을 조절할 수 있고 사용자의 위치에 따라 가장 가까운 서버로 연결하여 접속 속도를 향상시킬 수 있습니다. 또한 특정 서버에 문제가 발생하더라도 DNS 설정을 변경하여 다른 서버로 트래픽을 우회시켜 서비스 중단을 최소화할 수 있습니다.

### DNS 서버 유형
 
DNS 서버에는 여러 가지 유형이 있지만 가장 일반적인 DNS 서버는 재귀형(Recursive)과 권한형(Authoritative)으로 알려져 있습니다.

재귀형(Recursive) DNS 서버는 주어진 질문에 대한 답변을 다른 DNS 서버에 쿼리하는 서버입니다. 답변이 없는 경우 답변이 있는 서버를 찾을 때까지 추가 서버를 쿼리합니다. 이 유형의 서버는 일반적으로 개인 사용자와 소규모 비즈니스에서 사용합니다.

권한형(Authoritative) DNS 서버는 특정 도메인의 DNS 쿼리에 응답하고 브라우저 요청에 응답하여 웹사이트를 전달하는 서버입니다. 이 유형의 서버는 일반적으로 대규모 조직과 인터넷 서비스 공급자가 사용합니다.

### DNS 캐시

DNS 캐시는 DNS 서버가 최근에 조회한 정보를 임시로 저장해두는 공간입니다. 이를 통해 동일한 도메인에 대한 반복적인 조회 시 응답 시간을 단축하고 서버 부하를 줄여 DNS 시스템의 효율성을 높입니다.

DNS의 조회 과정에서 캐시의 역할이 중요합니다. 
응답 시간 단축을 위해 이미 조회한 정보를 캐시에 저장해 두므로, 동일한 도메인에 대한 다음 요청 시 Authoritative DNS 서버까지 다시 조회할 필요 없이 캐시된 정보를 바로 제공합니다.
자주 요청되는 도메인에 대한 정보는 캐시에 저장되어 Authoritative DNS 서버로의 부담을 줄여주고 불필요한 DNS 쿼리를 줄여 네트워크 트래픽을 감소시킵니다.

DNS 캐시는 일반적으로 TTL(Time To Live) 값에 따라 관리됩니다. TTL은 DNS 레코드에 설정된 유효 시간으로, 이 시간이 지나면 캐시된 정보는 무효화되고 다시 조회하게 됩니다.

TTL 설정: DNS 서버 관리자는 각 도메인의 TTL 값을 설정하여 캐시 유효 시간을 조절할 수 있습니다. 자주 변경되는 정보는 짧은 TTL을, 변경되지 않는 정보는 긴 TTL을 설정하는 것이 일반적입니다.
캐시 플러싱: 캐시에 오류 정보가 저장되어 있거나, 특정 도메인의 정보를 즉시 업데이트해야 할 경우, 캐시를 강제로 비우는 작업을 수행할 수 있습니다. 이를 캐시 플러싱이라고 합니다.
네거티브 캐싱: 존재하지 않는 도메인에 대한 조회 결과도 일정 시간 동안 캐시에 저장하여 불필요한 조회를 방지하는 기능입니다.
캐시 크기 제한: 캐시에 저장할 수 있는 정보의 양은 제한되어 있습니다. 캐시가 가득 차면 오래된 정보부터 삭제됩니다.


### DNS 조회 과정

DNS 조회 과정은 다음과 같이 이뤄집니다.

- 로컬 DNS 캐시 확인

컴퓨터는 먼저 자체적으로 가지고 있는 DNS 캐시를 검색합니다. 이전에 조회한 적 있는 도메인이라면 캐시된 IP 주소를 바로 사용하여 빠르게 연결할 수 있습니다.

- 재귀 쿼리

캐시에 해당 정보가 없으면, 운영체제는 ISP(Internet Service Provider)가 제공하는 DNS 서버에 재귀 쿼리를 보냅니다. 재귀 쿼리란, DNS 서버가 최종적인 IP 주소를 찾을 때까지 다른 DNS 서버에 쿼리를 계속 전달하는 방식입니다.

- Root DNS 서버 조회

ISP의 DNS 서버는 먼저 Root DNS 서버에 쿼리를 보냅니다. Root DNS 서버는 최상위 도메인(.com, .net 등)에 대한 정보를 가지고 있으며, 요청된 도메인의 TLD 서버를 알려줍니다.

- TLD DNS 서버 조회

Root DNS 서버에서 받은 정보를 바탕으로 ISP의 DNS 서버는 해당 TLD DNS 서버에 쿼리를 보냅니다. TLD DNS 서버는 특정 TLD(예: .com)에 대한 모든 도메인 정보를 가지고 있으며, 요청된 도메인의 Authoritative DNS 서버를 알려줍니다.

- Authoritative DNS 서버 조회

TLD DNS 서버에서 받은 정보를 바탕으로 ISP의 DNS 서버는 Authoritative DNS 서버에 쿼리를 보냅니다. Authoritative DNS 서버는 해당 도메인에 대한 가장 정확한 정보를 가지고 있으며, 최종적으로 요청된 도메인의 IP 주소를 반환합니다.

- IP 주소 반환

Authoritative DNS 서버에서 받은 IP 주소를 ISP의 DNS 서버는 다시 사용자의 컴퓨터로 전달합니다.

## 3. TCP 연결 (Transmission Control Protocol)

이제 DNS 과정을 거치고 찾아가려는 IP 주소를 받게 되었습니다. 이 IP를 통해 어떻게 웹 서버와 연결이 될 수 있을까요?

### IP와 라우터

IP 주소와 라우터를 이용해 인터넷 상에서 데이터 패킷이 이동하는 경로를 추적하여 특정 데이터의 출발지나 목적지를 파악할 수 있습니다.

- 라우터
라우터는 네트워크 상에서 데이터 패킷을 최적의 경로로 전달하는 장치입니다. 각 라우터는 연결된 네트워크 정보를 가지고 있으며, 이 정보를 바탕으로 데이터 패킷을 목적지로 안내합니다.

- IP 주소와 라우터를 이용한 추적 원리

패킷 헤더: 모든 데이터 패킷에는 출발지 IP 주소와 목적지 IP 주소가 포함된 헤더가 있습니다.
라우터의 역할: 데이터 패킷이 라우터를 통과할 때마다 라우터는 패킷 헤더의 목적지 IP 주소를 확인하고, 자신의 라우팅 테이블을 참조하여 다음으로 전달할 라우터를 결정합니다.
경로 추적: 이러한 과정을 반복하면서 데이터 패킷은 목적지까지 도달하게 되고, 각 라우터를 거치면서 경로 정보가 남게 됩니다.
추적 도구: traceroute와 같은 도구를 사용하여 데이터 패킷이 지나간 경로를 추적할 수 있습니다.

- IP 주소 추적 방법
traceroute: 특정 호스트까지 데이터 패킷이 지나가는 경로를 확인하는 명령어입니다. 각 라우터의 IP 주소와 응답 시간을 보여줍니다.
ping: 특정 호스트까지 데이터 패킷을 보내고 응답 시간을 측정하는 명령어입니다.
로그 분석: 웹 서버, 방화벽 등의 로그를 분석하여 접속 IP 주소를 확인할 수 있습니다.
IP 주소 조회 서비스: 특정 IP 주소에 대한 정보를 제공하는 온라인 서비스를 이용할 수 있습니다.

- IP 주소 추적의 활용
네트워크 문제 해결: 네트워크 연결이 느리거나 불안정할 때, traceroute를 사용하여 문제 발생 지점을 파악할 수 있습니다.
보안 분석: 해킹 시도나 악성 트래픽의 출처를 추적하여 보안 위협을 분석하고 대응할 수 있습니다.
네트워크 관리: 네트워크 구성 및 성능을 분석하고 최적화하는 데 활용될 수 있습니다.

- IP 주소 추적의 한계
IP 주소 변동: 동적 IP 주소를 사용하는 경우, IP 주소가 자주 변경되어 추적이 어려울 수 있습니다.
프록시 서버: 프록시 서버를 이용하면 실제 IP 주소를 숨길 수 있습니다.
VPN: VPN(Virtual Private Network)을 사용하면 가상의 IP 주소를 사용하여 추적을 어렵게 만들 수 있습니다.
TOR 네트워크: TOR 네트워크는 여러 노드를 거쳐 데이터를 전송하여 추적을 매우 어렵게 만듭니다.

### ARP(Address Resolution Protocol)

IP 주소는 논리적인 주소로, 네트워크 상에서 기기를 식별하는 데 사용됩니다. 반면, MAC 주소는 물리적인 주소로, 네트워크 카드에 고유하게 부여된 하드웨어 주소입니다. 네트워크에서 데이터를 전송할 때는 목적지의 MAC 주소를 알아야 합니다. 즉, IP 주소를 알고 있더라도 실제 데이터를 전송하기 위해서는 MAC 주소를 알아내야 합니다.

- ARP
ARP(Address Resolution Protocol)는 IP 주소를 MAC 주소로 변환하는 프로토콜입니다. 쉽게 말해, 우리가 익숙한 웹 주소(IP 주소)를 네트워크 카드가 직접 이해할 수 있는 물리적인 주소(MAC 주소)로 바꿔주는 역할을 합니다.

- ARP 작동 원리
1. ARP 요청:
어떤 컴퓨터 A가 다른 컴퓨터 B에게 데이터를 보내려고 할 때, A는 B의 IP 주소를 알고 있지만 MAC 주소를 모르는 경우가 많습니다.
A는 네트워크에 ARP 요청 패킷을 브로드캐스트합니다. 이 패킷에는 B의 IP 주소와 함께 "누가 이 IP 주소를 가지고 있습니까?"라는 질문이 포함되어 있습니다.

2. ARP 응답:
B는 자신이 요청받은 IP 주소를 가지고 있다면 ARP 응답 패킷을 보냅니다. 이 패킷에는 B의 MAC 주소가 포함되어 있습니다.
A는 B의 응답을 받아 자신의 ARP 캐시에 B의 IP 주소와 MAC 주소를 매핑합니다.

3. 데이터 전송:
A는 이제 B의 MAC 주소를 알게 되었으므로, 데이터 패킷의 목적지 MAC 주소에 B의 MAC 주소를 기입하고 데이터를 전송합니다.

- ARP 캐시

ARP 캐시는 각 컴퓨터에 저장되어 있는 IP 주소와 MAC 주소의 매핑 정보입니다.
한번 매핑된 정보는 캐시에 저장되어 다음에 같은 목적지로 데이터를 전송할 때 다시 ARP 요청을 보낼 필요가 없습니다.
하지만, 네트워크 환경이 변하거나 IP 주소가 변경되면 캐시 정보가 오래되어 문제가 발생할 수 있습니다.

### TCP 3-way handshake

DNS 조회를 통해 얻은 IP 주소를 바탕으로 브라우저는 서버에 TCP 연결을 요청합니다. 이때, TCP 3-way handshake라는 과정을 통해 양측은 연결을 확립합니다.
3-way handshake는 SYN, SYN-ACK, ACK 패킷을 주고받으며 연결을 설정하는 과정입니다.

왜 3-way handshake가 필요할까요?
신뢰성 있는 연결 확보를 위해 양쪽 모두 데이터를 주고받을 준비가 되었는지 확인하고, 안정적인 통신 환경을 구축합니다.
순서 번호 설정을 위해 데이터 전송 시 순서를 정확하게 유지하기 위한 초기 시퀀스 번호를 교환합니다.
오류 검출 및 재전송을 위해 연결 설정 과정에서 발생하는 오류를 미리 감지하고, 필요한 경우 재전송을 통해 연결을 재설정합니다.

- 3-way handshake 과정

1. SYN 패킷 전송:
클라이언트가 서버에 연결을 요청하는 SYN 패킷을 전송합니다. 이 패킷에는 클라이언트가 사용할 초기 시퀀스 번호가 포함되어 있습니다.
2. SYN-ACK 패킷 전송:
서버는 클라이언트의 연결 요청을 받고 SYN-ACK 패킷을 전송합니다. 이 패킷에는 서버가 사용할 초기 시퀀스 번호와 클라이언트가 보낸 SYN 패킷에 대한 응답(ACK)이 포함되어 있습니다.
3. ACK 패킷 전송:
클라이언트는 서버의 SYN-ACK 패킷을 받고 ACK 패킷을 전송합니다. 이 패킷에는 서버가 보낸 시퀀스 번호에 대한 응답이 포함되어 있습니다.

- 각 패킷의 의미
SYN (Synchronize): 연결 요청을 의미합니다.
ACK (Acknowledgement): 상대방이 보낸 패킷을 정상적으로 받았음을 확인하는 응답입니다.

## 4. HTTP

사용자가 웹 브라우저 주소창에 URL을 입력하면, 브라우저는 해당 URL에 대한 정보를 요청하는 HTTP 요청을 서버로 보냅니다. 서버는 브라우저의 요청을 받아 처리하고, 요청된 웹 페이지의 HTML, CSS, 이미지 등의 데이터를 담은 HTTP 응답을 보냅니다. 웹 페이지뿐만 아니라, 다양한 웹 애플리케이션 (예: 이메일, 온라인 쇼핑몰)에서 데이터를 주고받기 위해 HTTP를 사용합니다.

### HTTP(HyperText Transfer Protocol)

HTTP란 무엇일까요? HTTP(HyperText Transfer Protocol)는 하이퍼텍스트 전송 프로토콜의 약자로, 인터넷에서 웹 페이지를 주고받기 위한 기본적인 통신 규약입니다. 즉, 우리가 웹 브라우저를 통해 웹사이트를 방문하고 정보를 얻을 때 사용되는 언어라고 생각하면 쉽습니다.

- HTTP의 특징
클라이언트-서버 모델: 브라우저(클라이언트)가 서버에 요청하고, 서버가 응답하는 형태로 통신합니다.
무상태 프로토콜: 각 요청은 독립적이며, 서버는 이전 요청에 대한 정보를 저장하지 않습니다.
비연결형: 데이터를 주고받을 때마다 새로운 연결이 생성되고 종료됩니다.
텍스트 기반: HTTP 요청과 응답 메시지는 일반 텍스트 형식으로 구성됩니다.
확장성: 다양한 메서드(GET, POST, PUT 등)와 헤더를 사용하여 다양한 기능을 구현할 수 있습니다.

- HTTP 메서드
GET: 서버에서 특정 자원을 가져올 때 사용합니다. (예: 웹 페이지 조회)
POST: 서버에 데이터를 전송할 때 사용합니다. (예: 회원 가입, 게시글 작성)
PUT: 서버의 자원을 업데이트할 때 사용합니다.
DELETE: 서버의 자원을 삭제할 때 사용합니다.
HEAD: GET과 비슷하지만, 응답 본문 대신 헤더만 받습니다.
OPTIONS: 서버가 지원하는 HTTP 메서드를 확인할 때 사용합니다.

- HTTP 요청과 응답

HTTP 요청은 요청 라인, 헤더, 본문으로 구성됩니다.

요청 라인: 요청 메서드, 요청 URI, HTTP 버전으로 구성됩니다.
헤더: 요청에 대한 추가 정보를 담고 있습니다. (예: 사용자 에이전트, Accept, Content-Type)
본문: POST 메서드 등 일부 메서드에서 사용되며, 서버로 전송할 데이터를 포함합니다.

HTTP 응답도 마찬가지로 상태 라인, 헤더, 본문으로 구성됩니다.

상태 라인: HTTP 버전, 상태 코드, 상태 메시지로 구성됩니다. (예: HTTP/1.1 200 OK)
헤더: 응답에 대한 추가 정보를 담고 있습니다. (예: Content-Type, Content-Length)
본문: 요청된 데이터를 포함합니다.

- HTTP 버전
HTTP/1.0: 초기 HTTP 버전으로, 한 번의 연결로 하나의 요청만 처리할 수 있습니다.
HTTP/1.1: 지속 연결, 파이프라이닝 등의 기능을 추가하여 성능을 향상시켰습니다.
HTTP/2: 바이너리 프레임, 멀티플렉싱 등을 도입하여 성능을 더욱 향상시켰습니다.

- HTTP와 HTTPS의 차이
HTTP: 데이터를 암호화하지 않아 보안에 취약합니다.
HTTPS: SSL/TLS를 사용하여 데이터를 암호화하여 안전하게 통신합니다.

### HTTPS(HyperText Transfer Protocol Secure)

HTTPS는 HTTP(HyperText Transfer Protocol) 프로토콜의 보안 버전으로, 웹 통신 시 데이터를 암호화하여 안전하게 전송하는 프로토콜입니다. HTTP가 일반적인 웹 페이지를 주고받을 때 사용되는 프로토콜이라면, HTTPS는 온라인 뱅킹, 쇼핑몰 등 민감한 정보를 주고받는 사이트에서 주로 사용됩니다.

- HTTPS의 필요성
데이터 암호화: HTTPS는 SSL(Secure Sockets Layer) 또는 TLS(Transport Layer Security)라는 암호화 프로토콜을 사용하여 클라이언트와 서버 간의 통신을 암호화합니다. 이를 통해 해커가 통신 내용을 가로채더라도 내용을 해독할 수 없도록 만들어줍니다.
인증: HTTPS는 웹사이트의 신뢰성을 보장합니다. 웹 브라우저는 HTTPS 웹사이트에 접속할 때 해당 사이트의 디지털 인증서를 확인하여 사이트의 신원을 검증합니다.
데이터 무결성: HTTPS는 데이터가 전송되는 과정에서 변조되지 않았는지 확인합니다.

- HTTPS의 작동 원리
클라이언트의 접속 요청: 브라우저가 HTTPS 웹사이트에 접속하면, 서버에 연결 요청을 보냅니다.
서버의 인증서 전송: 서버는 자신을 증명하기 위한 디지털 인증서를 클라이언트에게 전송합니다.
인증서 검증: 클라이언트는 받은 인증서를 검증합니다. 신뢰할 수 있는 인증기관에서 발급한 인증서인지, 유효 기간이 지나지 않았는지 등을 확인합니다.
암호화 키 교환: 클라이언트와 서버는 안전한 암호화 키를 생성하고 교환합니다.
암호화된 통신: 이후 모든 통신은 생성된 암호화 키를 사용하여 암호화되어 전송됩니다.

- HTTPS의 주요 구성 요소
SSL/TLS: 데이터를 암호화하고 복호화하는 역할을 합니다.
디지털 인증서: 웹사이트의 신원을 증명하는 전자 문서입니다.
공개 키 암호화: 비밀 키와 공개 키를 사용하여 데이터를 암호화하고 복호화하는 방식입니다.

- HTTPS의 장점
보안 강화: 데이터 암호화, 인증, 무결성 보장을 통해 데이터 유출, 해킹 등의 위험을 줄입니다.
사용자 신뢰도 향상: HTTPS를 사용하는 웹사이트는 사용자에게 안전하다는 인식을 심어주어 신뢰도를 높입니다.
검색 엔진 최적화: 구글 등 많은 검색 엔진에서 HTTPS 웹사이트를 우대하여 검색 결과 상위에 노출될 가능성이 높습니다.

- HTTPS의 단점
성능 저하: 암호화 과정에서 약간의 성능 저하가 발생할 수 있습니다.
구축 비용: 디지털 인증서 발급 및 관리 비용이 발생할 수 있습니다.

## 5. 서버 처리 및 응답

서버에 요청을 보내면, 서버는 이 요청을 처리하고 결과를 다시 클라이언트에게 반환합니다.

### CDN(Content Delivery Network)

CDN은 전 세계에 분산된 서버 네트워크로, 콘텐츠를 사용자에게 가장 가까운 서버에서 제공하여 웹 페이지 로딩 속도를 향상시키는 기술입니다.

- 작동 원리
콘텐츠 캐싱: 자주 요청되는 정적 파일(HTML, CSS, 이미지 등)을 CDN 서버에 미리 저장합니다.
요청 라우팅: 사용자의 요청이 들어오면, 가장 가까운 CDN 서버로 라우팅하여 캐시된 콘텐츠를 빠르게 제공합니다.
동적 콘텐츠 처리: 동적 콘텐츠(DB에서 가져오는 데이터 등)는 원본 서버에서 처리한 후 CDN에 캐싱합니다.

- 장점
빠른 로딩 속도: 사용자에게 가장 가까운 서버에서 콘텐츠를 제공하여 지연 시간을 줄입니다.
서버 부하 분산: 원본 서버의 부하를 분산하여 서버 안정성을 높입니다.
글로벌 전달: 전 세계 사용자에게 빠르게 콘텐츠를 제공할 수 있습니다.

## 브라우저 렌더링

우리가 웹 페이지를 보게 되는 것은 단순히 서버에서 파일을 받아오는 것만으로는 불가능합니다. 브라우저는 서버에서 받아온 HTML, CSS, JavaScript 등의 코드를 해석하고, 이를 바탕으로 화면에 보이는 웹 페이지를 그려내는 복잡한 작업을 수행합니다. 이 과정을 브라우저 렌더링이라고 합니다.

1.HTML 파싱:

브라우저는 서버에서 받아온 HTML 코드를 읽고, 각 요소(태그)를 파악하여 DOM(Document Object Model)이라는 트리를 생성합니다. DOM은 HTML 문서의 구조를 나타내는 트리 형태의 데이터 구조입니다.

2. CSS 파싱

CSS 파일을 읽고 스타일 규칙을 파악하여 CSSOM(CSS Object Model)을 생성합니다. CSSOM은 DOM의 노드에 스타일을 적용하기 위한 정보를 담고 있습니다.

3. DOM과 CSSOM 결합

생성된 DOM과 CSSOM을 결합하여 렌더링 트리를 생성합니다. 렌더링 트리는 화면에 표시될 요소들과 각 요소의 스타일 정보를 담고 있습니다.

4. 레이아웃:

렌더링 트리의 요소들을 화면에 배치하기 위한 위치와 크기를 계산하는 과정입니다. 브라우저는 각 요소의 크기와 위치를 계산하여 레이아웃을 생성합니다.

5. 페인팅

레이아웃에 따라 각 요소를 화면에 그리는 과정입니다. 브라우저는 픽셀 단위로 화면을 채우면서 웹 페이지를 시각적으로 표현합니다.

6. 합성

여러 레이어로 구성된 요소들을 하나의 레이어로 합쳐 최종적으로 화면에 출력하는 과정입니다.

### 렌더링 최적화
압축: HTML, CSS, JavaScript 파일의 크기를 줄여 전송 시간을 단축합니다. 이를 위해 코드 분할, 압축, 캐싱 등의 기술을 활용할 수 있습니다.
번들링: 여러 파일을 하나의 파일로 합쳐 HTTP 요청 수를 줄입니다.
지연 로딩: 필요한 순간에만 자원을 로딩하여 초기 로딩 속도를 향상시킵니다.
웹폰트 최적화: 웹폰트 파일의 크기를 줄이고, 필요한 글자만 로딩합니다.
CSS 선택자 최적화: CSS 선택자를 효율적으로 작성하여 스타일 계산 시간을 줄입니다.

---
### 참고 자료

- HTTP 완벽 가이드
- [권한 DNS란 무엇일까요? | akamai](https://www.akamai.com/ko/glossary/what-is-authoritative-dns)
- [DNS란 무엇입니까? DNS 작동 원리 | cloudflare](https://www.cloudflare.com/ko-kr/learning/dns/what-is-dns/)
